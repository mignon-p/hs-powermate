{-|
Module      : PowerMate
Description : Read events from a Griffin PowerMate USB
Copyright   : Â© Patrick Pelletier, 2017
License     : BSD3
Maintainer  : code@funwithsoftware.org
Stability   : experimental
Portability : Linux

This module is for interfacing the Griffin PowerMate USB with Haskell.
-}

{-# LANGUAGE MultiWayIf #-}

module System.Hardware.PowerMate
  ( Knob
  , Event (..)
  , openController
  , openController'
  , nextEvent
  , setLed
  , closeController
  ) where

import Data.Word
import Foreign.Marshal.Alloc
import Foreign.Marshal.Utils
import Foreign.Storable
import System.IO

import System.Hardware.PowerMate.Foreign

-- | Represents a PowerMate USB controller.
newtype Knob = Knob Handle

-- | The events which can be generated by a PowerMate USB controller.
data Event = ButtonPressed | ButtonReleased | Clockwise | Counterclockwise
           deriving (Eq, Ord, Show, Read, Bounded, Enum)

powermateDevice :: FilePath
powermateDevice = "/dev/input/powermate"

-- | Open the PowerMate USB controller on @\/dev\/input\/powermate@.
--   (If that device file does not exist, see the @README.md@ about
--   creating a udev rule.)
openController :: IO Knob
openController = openController' powermateDevice

-- | Open a PowerMate USB controller with the specified device file.
--   You only need this if you have multiple PowerMates, or are doing
--   something else weird.
openController' :: FilePath -> IO Knob
openController' dev = do
  h <- openFile dev ReadWriteMode
  hSetBuffering h NoBuffering
  return $ Knob h

-- | Block until the PowerMate USB controller generates an event, and
--   then return that event.
nextEvent :: Knob -> IO Event
nextEvent k@(Knob h) = do
  ie <- readEvent h
  let et = eventType ie
      ec = eventCode ie
      ev = eventValue ie
  if | et == evKey && ev == 1    -> return ButtonPressed
     | et == evKey && ev == 0    -> return ButtonReleased
     | et == evRel && ev == 1    -> return Clockwise
     | et == evRel && ev == (-1) -> return Counterclockwise
     | otherwise                 -> nextEvent k

-- | Set the intensity of the blue LED on the PowerMate USB
--   controller.  0 is off and 255 is maximum intensity.
setLed :: Knob -> Word8 -> IO ()
setLed (Knob h) v = do
  writeEvent h $ InputEvent 0 0 evMsc mscPulseLed $ fromIntegral v

-- | Close the PowerMate USB controller.
closeController :: Knob -> IO ()
closeController (Knob h) = hClose h

readEvent :: Handle -> IO InputEvent
readEvent h = alloca $ \p -> do
  let sz = sizeOf (undefined :: InputEvent)
  ret <- hGetBuf h p sz
  if ret == sz
    then peek p
    else fail ("end-of-file on " ++ show h)

writeEvent :: Handle -> InputEvent -> IO ()
writeEvent h ie = with ie $ \p -> hPutBuf h p (sizeOf ie)
